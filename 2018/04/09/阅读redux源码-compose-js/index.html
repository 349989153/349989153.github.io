<!DOCTYPE html><html><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta http-equiv="X-UA-Compatible" content="ie=edge"><title>阅读redux源码--compose.js | 陆扬的个人博客</title><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://netdna.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css"><script src="/js/third-party/jquery.min.js">           </script><script src="/js/third-party/velocity.min.js">           </script><script src="/js/third-party/velocity.ui.min.js">           </script><link rel="icon" href="/img/favicon.ico"></head><body><nav id="nav-bar"><nav class="clear-fix" id="nav-container"><div class="pull-left" id="page-home"><a href="/">陆扬的个人博客</a></div><i class="fa fa-bars pull-right" id="toggle-nav" aria-hidden="true"></i><ul class="pull-right" id="navs"><li><a class="nav" href="/">Home</a></li><li><a class="nav" href="/about">About</a></li><li><a class="nav" href="/tags">Tags</a></li><li><a class="nav" href="/categories">Categories</a></li></ul></nav></nav><header id="header-info"><div id="header-container"><div id="site-info"><div id="terminal-pl"><div id="top-bar"><ul id="control"><li class="btn"></li><li class="btn"></li><li class="btn"></li></ul><div id="file-path"><i class="fa fa-folder folder-ic" aria-hidden="true"></i> 349989153 10 X 10</div></div><div id="code-pl">Last updated: 2018-04-09<br>349989153:~ Desktop$ <span class="code-pl-input">node 阅读redux源码--compose.js.js</span><br><br>> Post.tags <br><a class="tag" href="#js"><span>js</span></a><a class="tag" href="#redux"><span>redux</span></a><a class="tag" href="#源码"><span>源码</span></a><br><br></div></div></div></div></header><div id="content-outer"><div id="content-inner"><article id="post"><a class="article-title">阅读redux源码--compose.js</a><time class="article-date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-04-09</time><p>compose.js是redux里强大而又常被忽视的一个功能。</p>
<a id="more"></a>
<hr>
<h2 id="compose-js"><a href="#compose-js" class="headerlink" title="compose.js"></a>compose.js</h2><p>compose.js的源码相当简单：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">compose</span>(<span class="params">...funcs</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (funcs.length === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">arg</span> =&gt;</span> arg</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (funcs.length === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> funcs[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> funcs.reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> (...args) =&gt; a(b(...args)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>1.参数里面的…funcs起到了什么作用。</strong><br><strong>2.整个compose起到了什么作用。</strong></p>
<hr>
<p>…funcs起到的作用，就相当于把arguments转化为了一个数组。<br>但是细节可能有些不一样。我本来以为相当于：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compose</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(...arguments);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 但是实际上是</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compose</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log([...arguments]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>三个点<code>...</code>的语法，叫做<code>扩展语法</code>, 而<code>扩展语法</code>在函数中的应用，叫<code>剩余参数</code>。关于这点可以去看mdn的[扩展语法-mdn][1],这里不做过多展开。</p>
<hr>
<p><strong>关于compose做了什么，用中文解读一下源码好了。</strong><br>如果没有参数，返回一个函数，它接受什么就直接返回什么，不做任何处理。<br>如果有1个参数，那么返回这一个参数（这个参数应该是个函数）。<br>如果有2个以上的参数，那么对这些参数进行reduce操作，最后会返回一个函数，这个函数接收若干参数，并且执行最右边的函数，然后再用返回值执行之前组合好的函数。</p>
<p>举个例子吧，假设给<code>compose</code>传入的参数是<code>a,b,c</code>三个函数，那么<code>...funcs</code>就是<code>[a, b, c]</code>.我们用<code>cp</code>来表示之前的组合函数。<br>这样一来，执行了<code>compose</code>后，返回的函数是：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(...args) =&gt; cp1(c(...args))</span><br></pre></td></tr></table></figure>
<p>而cp1则是：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(...args) =&gt; cp2(b(...args))</span><br></pre></td></tr></table></figure>
<p>而cp2则是：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(...args) =&gt; a(...args)</span><br></pre></td></tr></table></figure></p>
<p>所以把cp2代入上面，再把cp1代入上上面就得到：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(...args) =&gt; a(b(c(...args)))</span><br></pre></td></tr></table></figure></p>
<hr>
<p>所以我们理解了，compose函数，其实是一个非常常用的抽象。它把传入其中的函数，按照从右到左的顺序按序执行，除了最右边的可以接收多个参数，剩下的函数都只能接收单个参数。<strong>也就是说compose把参数转化成一个连续的函数变换。</strong></p>
<p>只是感觉执行顺序有待商榷，我觉得compose从左到右的顺序可能会好些，毕竟先写的函数先执行，逻辑上可能较为通顺点。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> funcs.reverse().reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> (...args) =&gt; a(b(...args)))</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>一个典型的应用场景是用echarts.js绘制图表。<br>比如我们经常会抽象出一个函数来生成echarts的option：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> stackLine = (&#123;</span><br><span class="line">  dataset,</span><br><span class="line">  title,</span><br><span class="line">  yAxisName,</span><br><span class="line">  stackName,</span><br><span class="line">  xAxisData</span><br><span class="line">&#125;) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> option = &#123;</span><br><span class="line">    ...someOptionHere</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> option;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>但是写完后又会发现，这个图表的样式和那个有一点差异，怎么办呢？再写一个函数，然后把函数内把某些设置改一改？这样做的话，重复的代码太多，并且某些改动的通用型太低，对于颜色的改动，一个饼图和一个折线图可能要写2份代码。</p>
<p>一个较好的解决方法是，构造几个函数，它们接收一个option为参数，最后返回一个新的option。比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改颜色</span></span><br><span class="line"><span class="keyword">const</span> changeColor = <span class="function"><span class="params">option</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> opt = &#123; ...option &#125;;</span><br><span class="line">    opt.color = [<span class="string">'#000'</span>, <span class="string">'#fff'</span>];</span><br><span class="line">    <span class="keyword">return</span> opt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 修改y轴样式</span></span><br><span class="line"><span class="keyword">const</span> changeYAxisStyle = <span class="function"><span class="params">option</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> opt = &#123; ...option &#125;;</span><br><span class="line">    opt.yAxis.labelStyle = &#123;&#125;;</span><br><span class="line">    <span class="keyword">return</span> opt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 再修改label的啥啥啥</span></span><br><span class="line"><span class="keyword">const</span> changeLabel = <span class="function"><span class="params">option</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> opt = &#123; ...option &#125;;</span><br><span class="line">    opt.label.something = foo;</span><br><span class="line">    <span class="keyword">return</span> opt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>于是使用compose加上之前的stackLine，我们可以拿出一个按需修改的版本：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myStackLine = compose(changeColor, changeYAxisStyle, changeLabel ,stackLine)</span><br></pre></td></tr></table></figure>
<p>这样代码的灵活度也很高，哪个修改不需要，直接删掉，或者需要加上哪个修改，直接往上加。另外对于折线图的修改，饼图也能适用，真是非常不错。</p>
<hr>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>不读源码不知道，原来隐藏着这么一个强大而被忽略掉的地方。另外react的组件其实也是一个object，那么其实也适用这种组合变换的模式。<br>  [1]: <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Spread_syntax#%E8%AF%AD%E6%B3%95" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Spread_syntax#%E8%AF%AD%E6%B3%95</a></p>
</article><nav id="pagination"><div class="pagination clear-fix"></div></nav></div></div><footer><div id="footer-inner"><div class="social-icons"></div><p class="design-info">power by <a href="https://hexo.io" target="_blank">Hexo</a> | theme <a href="https://github.com/lazysheep666/terminal_theme" target="_blank">Teminal</a></p><p class="copyright">Copyright © 349989153 Blog 2018</p></div></footer><script src="/js/nav.js"></script><script src="/js/scroll.js"></script><script src="/js/index.js"></script></body></html>